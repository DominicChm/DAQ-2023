This document describes the format used in Dom's Logging Format (.dlf) files

# Overview
DLF files are designed to store constant-rate, constant-size temporal data with high efficiency and deterministic positioning.
Benefits include zero overhead beyond an initial header, deterministic the byte offsets, and 
Additionally, because DLF stores raw binary values, it requires little processing power to encode.
This makes DLF files ideal for high-rate DAQ (Data AQuisition) applications, especially where storage, RAM, or CPU is at a premium (such as in embedded systems or web browsers).  

What this all means, practically, is that DLF files can store data streams from sensors that are readable at drastically different rates (IE accelerometer@1000hz and GPS@10hz) without wasting space on repeated values. Additionally, because byte positions are deterministic and calculable, values at specific times can be precisely extracted from the overall datastream without needing to access or seek the rest of the file. 

DLF is based on ticks. Data can be recorded from any arbitrary fixed-size data source at any fixed multiple of ticks, up to one sample every tick. Each DLF file contains a "time base" which defines the time interval between ticks, in microseconds. A time base of 1000uS, for example, would translate to a maximum sample rate of 1kHz.  For example, with the aforementioned time base of 1kHz, a GPS might have a collection interval (`tick_interval`) of 100, resulting in collection at 1000Hz / 100 = 10Hz. Again, collections can happen up to once per tick. Increasing sample rate beyond once per tick requires the time base to decrease.

## Benefits
- Optimized storage

## Limitations
- unpredictable events (such as a button press) must be polled at a predetermined rate.
- variable-rate or variable-size data cannot be supported.
- There is no built-in mechanism to detect or recover corruption. Files are assumed to be perfect.
- Files cannot be trimmed by chopping data off. They must be fully reencoded.

# Structure
Each DLF file consists of two sections: header and data. The header is variable-length and spans from the start of the file to the data section. The data section spans from the end of the header to the end of the file.

## Header
The header defines metadata about the run as well as the data types present in the DLF data section.
All header strings are **fixed-length and null terminated**. While this makes loading headers slightly more complex, it allows for arbitrary-length descriptions and notes without reserving a large amount of space for those fields.
The header structure is as follows
```c
struct dlf_header_t {
    uint32_t magic = 0x8414;                //IDs DLF files. Also allows auto-detection of LSB/MSB encoding.
    uint32_t tick_base_us;                  // Base time interval, in us. Limits how fast samples will be stored.

    char application[32];                   // An arbitrary application-specific identifier. Used to select a metadata parser.  
    uint32_t meta_size = sizeof(meta_t);    // Metadata size stored in case there is no metadata parser available
    meta_t meta;                            // Metadata. Can be application-specific
    uint16_t meta_checksum;                 // Checksum over metadata.

    uint32_t num_streams;
    dlf_stream_header_t streams[num_streams];
}

// Defines a data stream present in this DLF file.
struct dlf_stream_header_t {
    char type_id[128];          // Data type identifier. Identifies type of contained data.
    char id[128];               // Unique identifier for this specific stream
    uint32_t tick_interval;     // Interval on which this stream is collected. 
    uint32_t tick_phase;        // Tick offset defining when this stream starts
    
    char notes[256];            // Anything that needs to be communicated about this data stream.
};

// Note: Metadata is application-specific, and should vary according to needs.
// This is an example implementation
struct meta_t {
    char title[1024];
    char description[4096];
    struct {
        char location_description[256];
        double longitude;
        double latitude;
    } location;
    uint64_t time;              // Epoch of this run's start
}
```
### Data Type Identifier
The structure of binary data is not stored with the data itself. Structures/parsers must be defined and stored externally.
The data type identifier is a short string which allows parsers to link to the appropriate type definition.
This can simply be the string "float" or "uint32" for simple types, or the name of a struct IE "suspension_data_t" for more complex types.  
This field can be autogenerated by the compiler using MVSC or GCC macros (using a fun function and the `__PRETTY_PRINT__` macro) to extract type names to avoid needing to manually specify type strings.

## Packing
Data is packed, and stored with the recorder's endianess.  